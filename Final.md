# CSAPP期末速成

## 第一章 计算机系统漫游

## 第二章 信息的表示和处理
### 2.1 信息存储
* **十进制、二进制和十六进制之间的转换**
* **字节顺序（大端和小端）**
  int a = 0x01234567
    |         地址          | 0x100 | 0x101 | 0x102 | 0x103 |
    | :-------------------: | :---: | :---: | :---: | :---: |
    | 大端（高位存低地址）  |  01   |  23   |  45   |  67   |
    | 小端 （高位存高地址） |  67   |  45   |  23   |  01   |
    
    **x86-64按小端存储！**
* **位运算（&, |, ~, ^）**
  * 与-And-**&**：A=1且B=1时，A&B=1
  * 或-Or-**|**：A=1或B=1时，A|B=1
  * 非-Not-**\~**：A=0时，~A=1
    * ~y = -y - 1
  * 异或-Xor-**^**：A $\neq$ B时（A=1，B=0或A=0，B=1）A^B=1
  *巧用异或*
    * 按位异或是一种加的形式
    * A ^ A = 0
      A ^ 0 = A
      A ^ 1 = ~A
  * 说明：都是位运算
* 逻辑运算（||, &&, !）
  逻辑运算的结果只有两种：0x00，0x01（真或假）
* **移位运算（逻辑移位、算术移位）， 有符号数据的算数右移**
  * 左移：x << y，将位向量x向左移动y位，扔掉左边多出的位，在右边补0
  * 右移：x >> y，将位向量x向右移动y位
    * 逻辑右移：在左边补0
    * 算数右移：复制左边的最高位（y次），有符号数都进行算数右移（保证符号位不变）

### 2.2 整数表示
* 无符号编码和有符号编码（二进制补码）
  * C数据类型的宽度（x86-64）
    | C数据类型 | x86-64 |
    | :-------: | :----: |
    |   char    |   1    |
    |   short   |   2    |
    |    int    |   4    |
    |   long    |   8    |
    |   float   |   4    |
    |  double   |   8    |
    |  pointer  |   8    |

    注意指针的字节长度，**无论char\*， int\*的长度都是8字节**
  * 有符号数和无符号数编码
    $1100_2 = 12_{10}$ 无符号
    $1100_2 = -4_{10}$ 有符号
    **区别：有符号最高位乘-1**
  * 最大值、最小值
    * 有符号数范围：1000 ~ 0111 （-8 ~ 7）
    * 无符号数范围：0000 ~ 1111 （0 ~ 15）
* 有符号和无符号之间的转换
  * 转换不改变二进制形式，只改变解读方式，对于超出范围的数进行+16或-16操作
  * 两个数比较，其中一个是无符号数，则另一个数也要转化成无符号数进行比较
  * 不写U默认有符号数
  * 显示转换、隐式转换
* 扩展和截断数字
  * 从long到int（截断）
     直接从中间截断，取低位，重新按有符号数或无符号数进行解读
  * 从int到long（扩展）
    * 有符号数：高位补和最高位相同（1100 -> 11111100)
    * 无符号数：直接补0（1100 -> 00001100）

### 2.3 整数运算
* 无符号、有符号数的加法（溢出、下溢）
  * 无符号数（取模，只存在正溢出）
    * 操作位：w位
    * 真实和：w+1位
    * 丢弃进位：截断，保留低w位
  * 有符号数（补码）
    * 操作位：w位
    * 真实和：w+1位
    * 丢弃进位：截断，保留低w位 
    存在正溢出和负溢出  
* 二进制补码的非
  * -8的非为-8，其余都是相反数
* 无符号、有符号数乘法（溢出）
  * 常用移位和加法（减法）来替代，提高效率
  * 无符号数除法采用逻辑右移（补0）
* 划分（超纲）

### 2.4（超纲）

## 第三章：程序的机器级表示
### 3.1 （超纲）
### 3.2 程序编码
### 3.3 数据格式
* 寄存器
   | 64位/8字节 | 32位/4字节 | 16位/2字节 | 8位/1字节 |     内容     |
   | :--------: | :--------: | :--------: | :-------: | :----------: |
   |    %rax    |    %eax    |    %ax     |    %al    |    返回值    |
   |    %rbx    |    %ebx    |    %bx     |    %bl    | 被调用者保存 |

   参数寄存器：rdi，rsi，rdx（依次存储）
   栈指针：rsp
### 3.4 获取信息
* 寄存器、操作数形式
  * 操作数
    * 寄存器：%eax
    * 内存：M[%ebp + 8]
    * 立即数: $4（0x开头为16进制，没有默认10进制）
  * 寄存器特点：访问速度快，数量少（16个）
* 数据移动指令 **（b：1字节，w：2字节，l：4字节，q：8字节）**
  * movx src,dst （x为b/w/l/q，表示传送数据的长度）
    |        汇编        |     C语言     |
    | :----------------: | :-----------: |
    |  movq $0x4, %rax   |  temp = 0x4   |
    | movq $-147, (%rax) |   *p = -147   |
    |  movq %rax, %rdx   | temp2 = temp1 |
    | movq %rax, (%rdx)  |   *p = temp   |
    | movq (%rax), %rdx  |   temp = *p   |

    单条指令不能实现从内存到内存的数据传递
  * 扩展传送指令
    * 符号扩展：movsbl （b -> l，补最高位）
    * 零扩展：movzbl（b -> l，补0）
    注意没有movzlq（和默认规则重复）
  * 寻址
    一般形式：D(Rb, Ri, S)
    Rb + Ri * S + D
    * D：常量，表示位移量
    * Rb：基址寄存器
    * Ri：变址寄存器
    * S：比例因子
    注意进制转换，一般都转成16进制（0x开头）
    > 例题
    mov_ %eax, (%rsp) -> movl(%eax 4字节)
    mov_ (%rax), %dx -> movw(%dx 2字节)
    mov_ $0xFF, %bl -> movb(%bl 1字节)
    **关键在于判断寄存器字节长度，前后大小相同**

    
* 压入和弹出堆栈数据
  %rsp保存当前栈顶元素地址
  push：先让rsp-8，开辟新地址，再保存值
  pop：先从栈中读取值，再rsp+8，恢复栈顶地址 
### 3.5 算术和逻辑运算
* 加载有效地址（lea）
  取地址，如果要读所取地址的值，要加括号
  lea (%rax), %rbx
* 其他
  * 移位操作
    * sal $4, %rax 左移4位（*16）
    * sar $4, %rax 算术右移4位（/16）
    * shr $4, %rax 逻辑右移
  * 算术运算
    * incq Dest （Dest += 1）
    * decq Dest （Dest -= 1）
    * negq Dest （Dest = -Dest）
    * notq Dest （Dest = ~Dest）转化成二进制后取反
    * addq Src, Dest (Dest = Dest + Src)
    * subq Src, Dest (Dest = Dest - Src)
    * imulq Src, Dest (Dest = Dest * Src)
    * sorq Src, Dest (Dest = Dest ^ Src)
    * andq Src, Dest (Dest = Dest & Src)
    * orq Src, Dest (Dest = Dest | Src) 
### 3.6 控制
* 条件码
  * CF：进位标志位（无符号数）
  * SF：符号标志位
  * ZF：零标志位
  * OF：溢出标志位
* 访问条件代码
  * cmp
    cmpq Src1, Src2：计算Src2 - Src1，但不保存结果，改变条件码
  * test
    test Src1， Src2 ：计算Src1 & Src2，设置条件码，不保存结果
  * set：读取条件码
* 条件控制
* 有条件移动 
* 循环：do-while <-> while <-> for
  * Do-While
    无论条件是否满足，先执行一次 
  * While
    先判断，若条件不满足，则直接跳出循环不执行
  * For
    三大条件：初始值，判断条件，自增/自减（init，test，update）   
* switch语句：难，跳转表结构实现
  
### 3.7 过程（函数）
* 运行时堆栈
* 控制转移
  * call：将返回地址压入堆栈
  * ret：从堆栈弹出返回地址
* 数据传输（参数，返回值）
* 堆栈上的本地存储
  * 堆栈帧
* 寄存器中的本地存储
  * 调用者保存，被调用者保存
* 递归过程
### 3.8 数组分配和访问
* 内存分配
* 访问
  ```C++
  int get_digit(zip_dig z, int digit){
    return z[digit];
  }
  ```
  ```py
  # 汇编
  # %rdi = z
  # %rsi = digit
  movl (%rdi, %rsi, 4), %eax # z[digit]
  ```

  * n * n矩阵的访问
    16 * 16为例，数组元素A[i][j]
    地址：A + i * (C * K) + j * k
    C = 16, K = 4(C与数组长度有关，K与类型int有关)

* 指针和数组
  int A1[3]
  int * A2[3]：指针数组，存储3个指针，长度8*3=24
  int (*A3)[3]：数组指针，A3是个指针，指向长度为4 * 3的数组，长度为8
  int (*A4[3])：同A2
### 3.9 异构数据结构
* 结构体
* 数据对齐
  ```c++
  struct S1{
    char c; //p+0
    int i[2]; //当前地址是p+1，补3bytes到p+4，变成4(int)的倍数
    double v; // 当前p+12，再补4bytes到p+16，变成8（double）的倍数
  } *p;
  ```
  要求：
  1. **每个元素的起始地址是类型字节大小的倍数**，不是倍数就补齐
  2. 结构体的总长度，是结构体中最大字节类型的倍数
  
  大的数据类型放在前面定义，可以节省空间？
* 联合union
  依据最大成员申请缓存，同时只能使用一个成员，所有元素共用存储空间 
### 3.10 在机器级程序中结合控制和数据
* 缓冲区溢出
  * 代码注入攻击
  * 面向回报的编程
* 保护
  * 代码中避免溢出漏洞（判断字符长度，检查是否溢出）
  * 系统级保护
    1. 随机的栈偏移：不能避免溢出，但可以避免被攻击
    2. 非可执行代码段：将栈中内容标记为不可执行，只能读取
  * 栈金丝雀
    在缓冲区中放置金丝雀，检查金丝雀的值是否被改变，来判断是否溢出 
### 3.11 （超纲）

## 第六章 存储器层次结构
### 6.1 存储技术
* DRSM（动态），SRAM（静态）
* 速度：寄存器 < CPU < SRAM < DRAM < SSD < 磁盘

### 6.2 局部性
**局部性原理**：程序倾向于使用最近一段时间，距离其较近地址的指令和数据
* 时间局部性：当前被访问的信息近期很可能还会被再次访问
* 空间局部性：最近将来用到的信息地址很可能与现在正在使用的信息在空间地址上是临近的
```c++
sum = 0;
for (int i = 0; i < n; i++){
    sum += a[i];
}
return sum;
/* 
对数据的引用
  顺序访问数组元素（步长为1的引用方式）：空间
  变量sum在每次循环迭代中被引用一次：时间
对指令的引用
  顺序读取指令：空间
  重复循环执行for循环体：时间
*/
```

### 6.3 存储器层次结构

### 6.4 高速缓存（Cache）
* Cache结构（S，E，B）
  组 - 行（1有效位+t标志位+B字节数据/块）- 数据
  $
  解：S = 2^s 组，每组E=2^e行，每块有B=2^b字节 
  $
  Cache大小C = S * E * B
  计算：给出地址总长度（如16），给出S组，B字节，计算t，s，b
  $
  s = \log_2 S, b = \log_2 B, t = 16 - s - b
  $
  * 直接映射（E = 1，即每组中只有1行）
  * 组相联（E = 2）
  * 全相联（只有一个组，组内有很多行，解决冲突不命中）
    成本高，应用少
* Cache Read
  * Cache miss
    写分配：加载到缓存，更新这个缓存行
    非写分配：直接写到主存，不加载到缓存
  * Cache hit
    直写：直接写入存储器
    写回：推迟写入内存，直到行要替换 
   一般采用写回+写分配
  * Cache eviction
    * 未命中时更换线路
* 缓存关联性

### 6.5 编写缓存友好型代码
面向cache，考虑局部性
* 矩阵乘法
   一般做法按列访问，破坏局部性
   优化方案
   1. 交换循环次序：用kij/ikj的次序，更多按行访问，利用局部性
   2. 分块矩阵
     将矩阵分成小块，可以将小块全部放到缓存中 
### 6.6 综合：缓存对程序性能的影响
* 重新排列循环以增加空间局部性 

 
## 第五章 优化
### 妨碍优化的障碍
* 函数调用
    ```c++
    void lower(char* s){
        size_t i;
        for (i = 0; i < strlen(s); i++)
            if (s[i] >= 'A' && s[i] <= 'Z')
                s[i] -= ('A' - 'a');
    }
    ```
    优化方法：把strlen(s)从循环中拿出来

* 存储器（内容）别名的使用
    ```c++
    void twiddle1(long *xp, long *yp){
        *xp += *yp;
        *xp += *yp;
    }

    void teiddle2(long *xp, long *yp){
        *xp += 2* *yp;
    }
    ```
    两个函数不一样，如果 *xp和 *yp指向同一地址，则两个函数的结果不同，编译器不直接优化。

### CPE：程序性能度量标准
测出来的，是一个估计值

### O1优化
一般有用的优化，可直接在编译时添加命令，不需要修改代码
* 代码移动：减少计算执行的频率（如把乘法从循环中拿出来）
* 复杂运算简化：用移位代替乘除

### 面向编译器优化（基础优化）
* 消除循环低效率
  把函数从循环中拿出来

* 减少过程调用
  函数调用优化为数组调用
  ```c++
  data_t *d = get_vec_start(v);
  ...
  // get_vec_element(v, i, &val);
  *dest = *dest OP d[i];
  ```

* 消除不必要的内存引用
  ```c++
  data_t t = IDENT;
  for (int i = 0; i < length; i++)
    t = t OP d[i];
    *dest = t;
  ```   
  用局部变量替代循环中的改变量
  原因：局部变量存在寄存器中，访问效率高  

### 面向CPU优化（循环展开）
本质：多条指令可同时执行（可同时执行4个整数运算） 
* 2*1
  ```c++
  acc = (acc OP data[i]) OP data[i+1]
  ``` 
* 2*1a
  ```c++
  acc = acc OP (data[i] OP data[i+1])
  ``` 
* 2*2
  ```c++
  x0 = x0 OP data[i];
  x1 = x1 OP data[i+1];
  ...
  *dest = x0 OP x1;
  ```  

## 第七章 链接
### 链接的步骤
**1. 符号解析**：找到不同文件中定义的符号的地址

**2. 重定位**
* 合并相关.o文件
* 确定每个符号的地址
* 在指令中填入新地址

### 链接器符号
* 全局符号：全局变量（非static）、函数
* 外部符号：在另一个函数中引用全局符号（extern一定是外部）
* 本地/局部符号：静态变量（static int）
  **注意：局部变量不是局部符号** 

### 符号强弱
* 强符号：函数、初始化的全局变量
* 弱符号：未初始化的全局变量

### 基于符号强弱的链接规则
* 不允许多个同名强符号
* 一强多弱，选择强
* 多个弱，任意选一个

## 第八章 异常控制流-异常和进程
### 硬件层异常
* 异步异常（中断）
* 同步异常
 1. 陷阱：用户态到内核态的接口（系统调用）
 2. 故障：不是有意的，可能被修复 
 3. 终止：非故意，不可恢复
  
### 进程
* 定义：进程是一个执行中程序的实例（一种抽象）
* 两个关键抽象：逻辑控制流、私有地址空间
* 并发；假并行
  在上下文切换时，保存进程私有的东西，不保存共有的（如：内核代码区）
* 进程的状态
  * 运行：正在执行或排队中
  * 停止：等待运行信号，开始排队
  * 终止：进程永远停止
    * 三种方式：收到信号、从主程序返回、调用exit函数
* 创建进程
  * 父进程调用fork函数进行创建子进程
  * 创建时，父进程和子进程几乎但不完全相同。PID不同
* fork函数
  * 调用一次，返回两次（PID）
  * 在子进程中返回0（pid==0表示子进程）
* 进程图 
* 回收进程
  由创建的父进程来回收，调用wait()函数 
  ```c++
  void fork(){
    int child_status;

    if (fork() == 0){
        printf("child");
        exit(0); // exit()调用1次，返回0次
    }
    else{
        printf("parent");
        wait(&child_status);
        printf("terminated");
    }
    printf("bye");
  }
  ```
### 信号
信号不排队
* 信号发送
* 接收信号
* 默认行为：进程运行、停止、终止

## 第九章 虚拟内存
### 虚拟地址 ——> 物理地址（结合第六章Cache）
* 虚拟地址（VA）组成
   1. VPN（虚拟页号） 
    * TLBI（TLB索引）
    * TLBT（TLB标记）
    （TLB：用来存储PTE的缓存）  
   2. VPO（偏移量）


* 物理地址（PA）
  1. PPO
  2. PPN 

* 为什么要引入虚拟内存？
   有效使用主存、简化内存管理、独立地址空间

* DRAM（物理内存）：虚拟内存系统缓存，在主存中缓存虚拟**页**（一页的大小约为4kB）

* 页表（PTE）：一个数组，每一项叫页表条目，由有效位 + 物理页号（磁盘地址）组成
  * Page Hit页命中：虚拟内存中的一个字已经缓存到物理内存中
  * Page Fault缺页，之后执行一系列算法，替换虚拟内存和DRAM中的内容
    如果页是空的，没有指向任何物理地址和虚拟地址，则再磁盘中分配一个新页，映射过来

* TLB
  * 组成：TLBT + TLBI 
  * 加速翻译过程

>示例
14位虚拟地址（n=14），12位物理地址（m=12），页面大小64字节（P=64）
则$VPO = PPO = \log_2 P = 6$
进而$VPN = n - VPO = 8, PPN = m - PPO = 6$

>TLB有16个条目，4路组相联
则共有$16 \div 4 = 4 = 2^2$组，故$TLBI = 2$
而$VPN = TLBT + TLBI, 故TLBT = 8 - 2 = 6$


* 地址翻译

### 内存管理：malloc，free（管理堆）


## 第十章 系统级IO
